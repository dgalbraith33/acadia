// Generated file -- DO NOT MODIFY.
#include "{{file}}.server.h"

#include <mammoth/debug.h>
#include <zcall.h>

namespace {

const uint32_t kSentinel = 0xBEEFDEAD;
const uint32_t kHeaderSize = 0x10;

void WriteError(glcr::ByteBuffer& buffer, glcr::ErrorCode err) {
  buffer.WriteAt<uint32_t>(0, kSentinel);
  buffer.WriteAt<uint32_t>(4, kHeaderSize);
  buffer.WriteAt<uint64_t>(8, err); 
}

void WriteHeader(glcr::ByteBuffer& buffer, uint64_t message_length) {
  buffer.WriteAt<uint32_t>(0, kSentinel);
  buffer.WriteAt<uint32_t>(4, kHeaderSize + message_length);
  buffer.WriteAt<uint64_t>(8, glcr::OK); 
}

}  // namespace


{% for interface in interfaces %}
void {{interface.name}}ServerBaseThreadBootstrap(void* server_base) {
  ({{interface.name}}ServerBase*)(server_base)->ServerThread();
}

Thread {{interface.name}}::RunServer() {
  return Thread({{interface.name}}ServerBaseThreadBootstrap, this);
}

void {{interface.name}}::ServerThread() {
  glcr::ByteBuffer recv_buffer(0x1000);
  glcr::ByteBuffer resp_buffer(0x1000);
  uint64_t resp_cap_size = 0x10;
  glcr::CapBuffer resp_cap(resp_cap_size);
  z_cap_t reply_port_cap;

  while (true) {
    uint64_t recv_buf_size = 0x1000;
    glcr::ErrorCode recv_err = ZEndpointRecv(endpoint_, &recv_buf_size, recv_buffer.RawPtr(), &reply_port_cap);
    if (recv_err != glcr::OK) {
      dbgln("Error in receive: %x", recv_err);
      continue;
    }

    uint64_t resp_length = 0;
    
    glcr::ErrorCode err = HandlRequest(recv_buffer, resp_buffer, resp_length, resp_cap);
    if (err != glcr::OK) {
      WriteError(resp_buffer, err);
      ZReplyPortSend(reply_port_cap, kHeaderSize, resp_buffer.RawPtr(), 0, nullptr);
    } else {
      WriteHeader(resp_buffer, resp_length);
      ZReplyPortSend(reply_port_cap, resp_length, resp_buffer.RawPtr(), resp_cap.UsedSlots(), resp_cap.RawPtr());
    }
  }

}

glcr::ErrorCode {{interface.name}}::HandleRequest(const glcr::ByteBuffer& request, glcr::ByteBuffer& response, uint64_t& resp_length
                                                  glcr::CapBuffer& resp_caps) {
  if (recv_buffer.At<uint32_t>(0) != kSentinel) {
    return glcr::INVALID_INPUT;
  } 
  
  uint64_t method_select = recv_buffer.At<uint64_t>(8);

  switch(method_select) {
{%- for method in interface.methods %}
    case {{loop.index0}}: {
      {{method.request}} request;
      {{method.response}} response;

      request.ParseFromBytes(recv_buffer, kHeaderSize);

      RET_ERR(Handle{{method.name}}(request, response));

      resp_length = response.SerializeToBytes(resp_buffer, kHeaderSize, resp_cap);
      break;
    }
{%- endfor %}
    default: {
      return glcr::UNIMPLEMENTED;
    }
  }
  return glcr::OK;
}
{% endfor %}
